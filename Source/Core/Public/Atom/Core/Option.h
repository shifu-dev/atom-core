#pragma once
#include "_OptionImpl.h"

namespace Atom
{
    template <typename T>
    class Option
    {
        template <typename T1>
        friend class Option;
        
        using _Impl = _OptionImpl<T>;
        using _ImplCtorNoVal = _Impl::CtorNoVal;

    public:
        using TValue = T;

    public:
        /// ----------------------------------------------------------------------------------------
        /// Default Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option():
            _impl{ _ImplCtorNoVal{} } { }

        /// ----------------------------------------------------------------------------------------
        /// Trivial Copy Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(const Option& that)
            requires(RTriviallyCopyConstructible<T>)
            = default;

        /// ----------------------------------------------------------------------------------------
        /// Copy Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(const Option& that)
            requires(RCopyConstructible<T>)
                and (not RTriviallyCopyConstructible<T>)
        {
            _impl.copyConstructValueFromOption(that._impl);
        }

        /// ----------------------------------------------------------------------------------------
        /// Trivial Copy Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(const Option& that) -> Option&
            requires(RTriviallyCopyAssignable<T>)
            = default;

        /// ----------------------------------------------------------------------------------------
        /// Copy Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(const Option& that) -> Option&
            requires(RCopyAssignable<T>)
                and (not RTriviallyCopyAssignable<T>)
        {
            _impl.copyAssignValueFromOption(that._impl);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Trivial Move Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(Option&& that)
            requires(RTriviallyMoveConstructible<T>)
            = default;

        /// ----------------------------------------------------------------------------------------
        /// Move Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(Option&& that)
            requires(RMoveConstructible<T>)
                and (not RTriviallyMoveConstructible<T>)
        {
            _impl.moveConstructValueFromOption(that._impl);
        }

        /// ----------------------------------------------------------------------------------------
        /// Trivial Move Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(Option&& that) -> Option&
            requires(RTriviallyMoveAssignable<T>)
            = default;

        /// ----------------------------------------------------------------------------------------
        /// Move Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(Option&& that) -> Option&
            requires(RMoveAssignable<T>)
                and (not RTriviallyMoveAssignable<T>)
        {
            _impl.moveAssignValueFromOption(mov(that._impl));
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Param Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(const T& val):
            _impl{ val } { }

        /// ----------------------------------------------------------------------------------------
        /// Param Move Constructor.
        /// ----------------------------------------------------------------------------------------
        constexpr ctor Option(T&& val):
            _impl{ mov(val) } { }

        /// ----------------------------------------------------------------------------------------
        /// Param Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(const T& val) -> Option&
        {
            _impl.assignValue(val);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Param Move Operator.
        /// ----------------------------------------------------------------------------------------
        constexpr fn op=(T&& val) -> Option&
        {
            _impl.assignValue(mov(val));
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Trivial Destructor.
        /// ----------------------------------------------------------------------------------------
        constexpr dtor Option()
            requires(RTriviallyDestructible<T>)
            = default;

        /// ----------------------------------------------------------------------------------------
        /// Destructor.
        /// ----------------------------------------------------------------------------------------
        constexpr dtor Option()
            requires(RDestructible<T>)
                and (not RTriviallyDestructible<T>)
        {
            _impl.destroyValue();
        }

    public:
        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() & -> T&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return _impl.getValue();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() const& -> const T&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return _impl.getValue();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() && -> T&&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return mov(_impl.getValue());
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() & -> T&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() const& -> const T&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() && -> T&&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op->() -> T*
        {
            return &value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op->() const -> const T*
        {
            return &value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        template <typename TInvokable>
        constexpr fn valueOrInvoke(TInvokable&& other) const -> const T&
            requires RInvokable<TInvokable, const T&()>
        {
            if (not _impl.isValue())
            {
                return other();
            }

            return _impl.getValue();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn valueOr(const T& other) const -> const T&
        {
            return valueOrInvoke([&other]()
                {
                    return other;
                });
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn valueOrDefault() const -> const T&
        {
            return valueOrInvoke([&]()
                {
                    return _impl.GetDefault();
                });
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn isValue() const -> bool
        {
            return _impl.isValue();
        }

    private:
        _Impl _impl;
    };

    template <typename T>
    class Option<T&> extends Option<T*>
    {
        using Base = Option<T*>;

    public:
        constexpr ctor Option(T& ref):
            Base{ &ref } { }

        using Base::Base;
        using Base::op=;

    public:
        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() & -> T&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return *_impl.getValue();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() const& -> const T&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return *_impl.getValue();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn value() && -> T&&
        {
            debug_expects(isValue(), "Doesn't contain value.");

            return mov(*_impl.getValue());
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() & -> T&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() const& -> const T&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op*() && -> T&&
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op->() -> T*
        {
            return value();
        }

        /// ----------------------------------------------------------------------------------------
        /// 
        /// ----------------------------------------------------------------------------------------
        constexpr fn op->() const -> const T*
        {
            return value();
        }

        using Base::isValue;
    
    private:
        using Base::_impl;
    };

    template <typename T>
    class Option<T&&>
    {
        static_assert(sizeof(T) == -1, "rvalue reference types are not supported.");
    };
}