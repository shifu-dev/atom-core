#pragma once
#include <mutex>

#include "Atom/Core.h"
#include "Atom/Memory/Lockable.h"

namespace Atom
{
    /// --------------------------------------------------------------------------------------------
    /// SimpleMutex implementation.
    /// 
    /// @TODO Implement this class without {std::lock}.
    /// --------------------------------------------------------------------------------------------
    class SimpleMutex
    {
    public:
        /// ----------------------------------------------------------------------------------------
        /// DefaultConstructor.
        /// 
        /// @POST Mutex is not locked.
        /// ----------------------------------------------------------------------------------------
        ctor SimpleMutex() noex { }

        /// ----------------------------------------------------------------------------------------
        /// CopyConstructor is deleted.
        /// ----------------------------------------------------------------------------------------
        ctor SimpleMutex(const SimpleMutex& other) = delete;

        /// ----------------------------------------------------------------------------------------
        /// MoveConstructor is delete.
        /// ----------------------------------------------------------------------------------------
        ctor SimpleMutex(SimpleMutex&& other) = delete;

        /// ----------------------------------------------------------------------------------------
        /// CopyOperator is deleted.
        /// ----------------------------------------------------------------------------------------
        fn operator = (const SimpleMutex& other) = delete;

        /// ----------------------------------------------------------------------------------------
        /// MoveOperator is delete.
        /// ----------------------------------------------------------------------------------------
        fn operator = (SimpleMutex&& other) = delete;

        /// ----------------------------------------------------------------------------------------
        /// Destructor.
        /// 
        /// @NOTE If lock is locked by some thread and lock is destroyed, behaviour is undefined.
        /// ----------------------------------------------------------------------------------------
        dtor SimpleMutex() { }

    public:
        /// ----------------------------------------------------------------------------------------
        /// Locks the lock. If the lock is already locked by some thread then blocks the calling
        /// thread until lock is acquired.
        /// 
        /// @SEE TryLock().
        /// ----------------------------------------------------------------------------------------
        fn Lock()
        {
            _impl.lock();
        }

        /// ----------------------------------------------------------------------------------------
        /// Tries to lock the lock. If the lock is already locked by some thread then returns but 
        /// doesn't blocks the thread.
        /// 
        /// @RETURNS {true} if lock acquired, else {false}.
        /// ----------------------------------------------------------------------------------------
        fn TryLock() -> bool
        {
            return _impl.try_lock();
        }

        /// ----------------------------------------------------------------------------------------
        /// Unlocks the lock.
        /// ----------------------------------------------------------------------------------------
        fn Unlock()
        {
            _impl.unlock();
        }

    private:
        /// ----------------------------------------------------------------------------------------
        /// Mutex implementation.
        /// ----------------------------------------------------------------------------------------
        std::mutex _impl;
    };

    static_assert(RLockable<SimpleMutex>);
}