#pragma once
#include "IterReqChecks.h"

namespace Atom
{
    /// --------------------------------------------------------------------------------------------
    /// ArrIter iterates over raw arr.
    /// --------------------------------------------------------------------------------------------
    template <typename T>
    requires(not RConst<T>)
    class ArrIter
    {
    public:
        using TElem = T;

    public:
        /// ----------------------------------------------------------------------------------------
        /// # Default Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr ArrIter()
            : _it{ nullptr } {}

        /// ----------------------------------------------------------------------------------------
        /// # Value Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr ArrIter(const T* it)
            : _it{ it } {}

    public:
        /// ----------------------------------------------------------------------------------------
        /// Access value by ref.
        /// ----------------------------------------------------------------------------------------
        constexpr auto value() const -> const T&
        {
            return *_it;
        }

        /// ----------------------------------------------------------------------------------------
        /// Access value by ptr.
        /// ----------------------------------------------------------------------------------------
        constexpr auto data() const -> const T*
        {
            return this->_it;
        }

        /// ----------------------------------------------------------------------------------------
        /// Check if this iter is same as `that`. Used to compare wth end.
        /// ----------------------------------------------------------------------------------------
        constexpr auto equals(const ArrIter& that) const -> bool
        {
            return this->_it == that._it;
        }

        /// ----------------------------------------------------------------------------------------
        /// Move fwd by `steps`.
        /// ----------------------------------------------------------------------------------------
        constexpr auto next(usize steps = 1) -> ArrIter&
        {
            _it += steps.val();
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Move bwd by `steps`.
        /// ----------------------------------------------------------------------------------------
        constexpr auto prev(usize steps = 1) -> ArrIter&
        {
            _it -= steps.val();
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Compares `this` data with `that` data.
        /// ----------------------------------------------------------------------------------------
        constexpr auto compare(const ArrIter& that) const -> isize
        {
            return this->_it - that._it;
        }

    protected:
        const T* _it;
    };

    /// --------------------------------------------------------------------------------------------
    /// MutArrIter iterates over mut raw arr.
    /// --------------------------------------------------------------------------------------------
    template <typename T>
    requires(not RConst<T>)
    class MutArrIter: public ArrIter<T>
    {
        using Base = ArrIter<T>;

    public:
        using TElem = T;

    public:
        /// ----------------------------------------------------------------------------------------
        /// # Default Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr MutArrIter()
            : Base{ } {}

        /// ----------------------------------------------------------------------------------------
        /// # Value Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr MutArrIter(T* it)
            : Base{ it } {}

    public:
        /// ----------------------------------------------------------------------------------------
        /// Access value by mut ref.
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutValue() -> T&
        {
            return const_cast<T&>(Base::value());
        }

        /// ----------------------------------------------------------------------------------------
        /// Access value by mut ptr.
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutData() -> T*
        {
            return const_cast<T*>(Base::data());
        }

        /// ----------------------------------------------------------------------------------------
        /// Move fwd by `steps`.
        /// ----------------------------------------------------------------------------------------
        constexpr auto next(usize steps = 1) -> MutArrIter&
        {
            Base::next(steps);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// Move bwd by `steps`.
        /// ----------------------------------------------------------------------------------------
        constexpr auto prev(usize steps = 1) -> MutArrIter&
        {
            Base::prev(steps);
            return *this;
        }
    };

    ATOM_SATISFIES_ARR_ITER_TEMP(ArrIter);
    ATOM_SATISFIES_MUT_ARR_ITER_TEMP(ArrIter);
}
