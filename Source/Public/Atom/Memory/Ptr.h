#pragma once
#include "Atom/Core/Primitives.h"
#include "Atom/TTI.h"

namespace Atom
{
    // clang-format off

    template <typename TPtr>
    concept RConstPtr = requires(TPtr ptr)
    {
        typename TPtr::TVal;

        { ptr.unwrap() } -> RConvertibleTo<const typename TPtr::TVal*>;
    };

    template <typename TPtr>
    concept RPtr = requires(TPtr ptr)
    {
        requires RConstPtr<TPtr>;

        { ptr.unwrap() } -> RSameAs<typename TPtr::TVal*>;
    };

    template <typename TPtr, typename T>
    concept RPtrOf = requires(TPtr ptr)
    {
        requires RPtr<TPtr>;
        requires RSameAs<T, typename TPtr::TVal>;
    };

    // clang-format on

    template <typename T>
    class MutPtr;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <typename TVal_>
    class Ptr
    {
        static_assert(TTI::IsPure<TVal_>, "Ptr only supports pure types.");
        static_assert(not TTI::IsVoid<TVal_>, "Ptr doesn't support void.");

    private:
        using This = Ptr<TVal_>;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        using TVal = TVal_;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr():
            _ptr{ nullptr }
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(This&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(This&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(std::nullptr_t):
            _ptr{ nullptr }
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr Ptr(const TPtr& ptr)
            requires(RConstPtr<TPtr>) and (RConvertibleTo<const typename TPtr::TVal*, const TVal*>)
            :
            _ptr{ static_cast<const TVal*>(ptr.unwrap()) }
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr Ptr& operator=(const TPtr& ptr)
            requires(RConstPtr<TPtr>) and (RConvertibleTo<const typename TPtr::TVal*, const TVal*>)
        {
            _ptr = static_cast<const TVal*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const TVal* ptr):
            _ptr{ ptr }
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const TVal* ptr)
        {
            _ptr = ptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~Ptr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto val() const -> const TVal&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *_ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkVal() const -> const TVal&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *_ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator->() const -> const TVal*
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return _ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> Ptr<T>
            requires RConvertibleTo<const TVal*, const T*>
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unsafeAs() const -> Ptr<T>
        {
            return reinterpret_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto dynAs() const -> Ptr<T>
            requires RPolymorphic<TVal> and RPolymorphic<T>
        {
            return dynamic_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asMut() const -> MutPtr<TVal>
        {
            return const_cast<TVal*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto isNull() const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(std::nullptr_t) const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(std::nullptr_t) const -> bool
        {
            return not eq(nullptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(const This& that) const -> bool
        {
            return unwrap() == that.unwrap();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(const This& that) const -> bool
        {
            return not eq(that);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> const TVal*
        {
            return _ptr;
        }

    public:
        /// ----------------------------------------------------------------------------------------
        /// # To Do
        ///
        /// - May be we should remove this.
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator*() const -> const TVal&
        {
            return val();
        }

    protected:
        const TVal* _ptr;
    };

    template <typename T>
    Ptr(const T* ptr) -> Ptr<T>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <>
    class Ptr<void>
    {
        using This = Ptr<void>;

    public:
        using TVal = void;

    public:
        /// ----------------------------------------------------------------------------------------
        /// # Default Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr():
            _ptr{ nullptr }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Copy Constructr
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Copy Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Move Constuctor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(This&&) = delete;

        /// ----------------------------------------------------------------------------------------
        /// # Move Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(This&&) = delete;

        /// ----------------------------------------------------------------------------------------
        /// # Null Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(std::nullptr_t):
            _ptr{ nullptr }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Null Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Constructor
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr Ptr(const TPtr& ptr)
            requires(RConstPtr<TPtr>)
            :
            _ptr{ static_cast<const void*>(ptr.unwrap()) }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Operator
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr Ptr& operator=(const TPtr& ptr)
            requires(RConstPtr<TPtr>)
        {
            _ptr = static_cast<const void*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Value Constructor
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr(const T* ptr):
            _ptr{ static_cast<const void*>(ptr) }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Value Operator
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr& operator=(const T* ptr)
        {
            _ptr = static_cast<const void*>(ptr);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Destructor
        /// ----------------------------------------------------------------------------------------
        constexpr ~Ptr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto val() const -> const byte&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkVal() const -> const byte&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> Ptr<T>
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asMut() const -> MutPtr<void>;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto isNull() const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(std::nullptr_t) const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(std::nullptr_t) const -> bool
        {
            return not eq(nullptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr auto eq(const TPtr& that) const -> bool
            requires(RConstPtr<TPtr>)
        {
            return unwrap() == that.unwrap();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr auto ne(const TPtr& that) const -> bool
            requires(RConstPtr<TPtr>)
        {
            return not(eq(that));
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> const void*
        {
            return _ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unwrapAs() const -> const T*
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrapAsByte() const -> const byte*
        {
            return static_cast<const byte*>(_ptr);
        }

    protected:
        const void* _ptr;
    };

    Ptr(const void*) -> Ptr<void>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <typename TVal_>
    class MutPtr: public Ptr<TVal_>
    {
        static_assert(TTI::IsPure<TVal_>, "MutPtr only supports pure types.");
        static_assert(not TTI::IsVoid<TVal_>, "MutPtr doesn't support void.");

    private:
        using This = MutPtr<TVal_>;
        using Base = Ptr<TVal_>;

    public:
        using TVal = Base::TVal;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr() = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(MutPtr&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(MutPtr&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(std::nullptr_t):
            Base(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr(TPtr& ptr)
            requires(RPtr<TPtr>) and (RConvertibleTo<typename TPtr::TVal*, TVal*>)
            :
            Base(static_cast<TVal*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr(TPtr&& ptr)
            requires(RPtr<TPtr>) and (RConvertibleTo<typename TPtr::TVal*, TVal*>)
            :
            Base(static_cast<TVal*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr& operator=(TPtr& ptr)
            requires(RPtr<TPtr>) and (RConvertibleTo<typename TPtr::TVal*, TVal*>)
        {
            _ptr = static_cast<TVal*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(TVal* ptr):
            Base(ptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(TVal* ptr)
        {
            _ptr = ptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~MutPtr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutVal() -> TVal&
        {
            return *_mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator->() -> TVal*
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() -> MutPtr<T>
            requires RPure<T> and RConvertibleTo<TVal*, T>
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unsafeAs() -> MutPtr<T>
            requires RPure<T>
        {
            return reinterpret_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto dynAs() -> MutPtr<T>
            requires RPolymorphic<TVal> and RPure<T> and RPolymorphic<T>
        {
            return dynamic_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asConst() -> Ptr<TVal>
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> TVal*
        {
            return _mutPtr();
        }

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator*() -> TVal&
        {
            return *_mutPtr();
        }

    private:
        constexpr auto _mutPtr() const -> TVal*
        {
            return const_cast<TVal*>(_ptr);
        }

    protected:
        using Base::_ptr;
    };

    template <typename T>
    MutPtr(T* ptr) -> MutPtr<T>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <>
    class MutPtr<void>: public Ptr<void>
    {
        using This = MutPtr<void>;
        using Base = Ptr<void>;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr() = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(MutPtr&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(MutPtr&&) = delete;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(std::nullptr_t):
            Base(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr(TPtr& ptr)
            requires(RPtr<TPtr>)
            :
            Base(static_cast<void*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr(TPtr&& ptr)
            requires(RPtr<TPtr>)
            :
            Base(static_cast<void*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename TPtr>
        constexpr MutPtr& operator=(TPtr& ptr)
            requires(RPtr<TPtr>)
        {
            _ptr = static_cast<void*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr(T* ptr)
            requires(not RConst<T>)
            :
            Base(static_cast<void*>(ptr))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr& operator=(T* ptr)
            requires(not RConst<T>)
        {
            _ptr = static_cast<void*>(ptr);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~MutPtr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutVal() const -> byte&
        {
            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto mutValAs() const -> T&
            requires RPure<T>
        {
            return *unwrapAs<T>();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> MutPtr<T>
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asConst() const -> Ptr<void>
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> void*
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unwrapAs() const -> T*
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrapAsByte() const -> byte*
        {
            return static_cast<byte*>(_mutPtr());
        }

    private:
        constexpr auto _mutPtr() const -> void*
        {
            return const_cast<void*>(_ptr);
        }

    protected:
        using Base::_ptr;
    };

    MutPtr(void*) -> MutPtr<void>;

    /// ----------------------------------------------------------------------------------------
    ///
    /// ----------------------------------------------------------------------------------------
    constexpr auto Ptr<void>::asMut() const -> MutPtr<void>
    {
        return const_cast<void*>(_ptr);
    }
}
