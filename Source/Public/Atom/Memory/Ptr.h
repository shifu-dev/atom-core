#pragma once
#include "Atom/Core/Primitives.h"
#include "Atom/TTI.h"

namespace Atom
{
    template <typename T>
    class MutPtr;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <typename TVal_>
    class Ptr
    {
        static_assert(TTI::IsPure<TVal_>, "Ptr only supports pure types.");
        static_assert(not TTI::IsVoid<TVal_>, "Ptr doesn't support void.");

    private:
        using This = Ptr<TVal_>;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        using TVal = TVal_;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr()
            : _ptr(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(This&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(This&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(std::nullptr_t)
            : _ptr(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr(const Ptr<T>& ptr)
            requires RConvertibleTo<T*, TVal*>
            : _ptr(static_cast<const TVal*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr& operator=(Ptr<T> ptr)
            requires RConvertibleTo<T*, TVal*>
        {
            _ptr = static_cast<const TVal*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const TVal* ptr)
            : _ptr(ptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const TVal* ptr)
        {
            _ptr = ptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~Ptr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto val() const -> const TVal&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *_ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkVal() const -> const TVal&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *_ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator->() const -> const TVal*
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return _ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> Ptr<T>
            requires RPure<T> and RConvertibleTo<TVal*, T*>
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unsafeAs() const -> Ptr<T>
            requires RPure<T>
        {
            return reinterpret_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto dynAs() const -> Ptr<T>
            requires RPolymorphic<TVal> and RPure<T> and RPolymorphic<T>
        {
            return dynamic_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asMut() const -> MutPtr<TVal>
        {
            return const_cast<TVal*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto isNull() const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(std::nullptr_t) const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(std::nullptr_t) const -> bool
        {
            return not eq(nullptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(const This& that) const -> bool
        {
            return unwrap() == that.unwrap();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(const This& that) const -> bool
        {
            return not eq(that);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> const TVal*
        {
            return _ptr;
        }

    protected:
        const TVal* _ptr;
    };

    template <typename T>
    Ptr(const T* ptr) -> Ptr<T>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <>
    class Ptr<void>
    {
        using This = Ptr<void>;

    public:
        using TVal = void;

    public:
        /// ----------------------------------------------------------------------------------------
        /// # Default Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr()
            : _ptr(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Copy Constructr
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Copy Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(const This&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Move Constuctor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(This&&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Move Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(This&&) = default;

        /// ----------------------------------------------------------------------------------------
        /// # Null Constructor
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr(std::nullptr_t)
            : _ptr(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Null Operator
        /// ----------------------------------------------------------------------------------------
        constexpr Ptr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Constructor
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr(const Ptr<T>& ptr)
            : _ptr{ static_cast<const void*>(ptr.unwrap()) }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Operator
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr& operator=(const Ptr<T>& ptr)
        {
            _ptr = static_cast<const void*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Value Constructor
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr(const T* ptr)
            requires RPure<T>
            : _ptr{ static_cast<const void*>(ptr) }
        {}

        /// ----------------------------------------------------------------------------------------
        /// # Value Operator
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr Ptr& operator=(const T* ptr)
            requires RPure<T>
        {
            _ptr = static_cast<const void*>(ptr);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        /// # Destructor
        /// ----------------------------------------------------------------------------------------
        constexpr ~Ptr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto val() const -> const byte&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkVal() const -> const byte&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto valAs() const -> const T&
            requires RPure<T>
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *unwrapAs<T>();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto checkValAs() const -> const T&
            requires RPure<T>
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *unwrapAs<T>();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> Ptr<T>
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asMut() const -> MutPtr<void>;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto isNull() const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto eq(std::nullptr_t) const -> bool
        {
            return unwrap() == nullptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto ne(std::nullptr_t) const -> bool
        {
            return not eq(nullptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto eq(const Ptr<T>& that) const -> bool
        {
            return unwrap() == that.unwrap();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto ne(const Ptr<T>& that) const -> bool
        {
            return not eq(that);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> const void*
        {
            return _ptr;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unwrapAs() const -> const T*
        {
            return static_cast<const T*>(_ptr);
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrapAsByte() const -> const byte*
        {
            return static_cast<const byte*>(_ptr);
        }

    protected:
        const void* _ptr;
    };

    Ptr(const void*) -> Ptr<void>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <typename TVal_>
    class MutPtr: public Ptr<TVal_>
    {
        static_assert(TTI::IsPure<TVal_>, "MutPtr only supports pure types.");
        static_assert(not TTI::IsVoid<TVal_>, "MutPtr doesn't support void.");

    private:
        using This = MutPtr<TVal_>;
        using Base = Ptr<TVal_>;

    public:
        using TVal = Base::TVal;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr() = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(MutPtr&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(MutPtr&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(std::nullptr_t)
            : Base(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr(const MutPtr<T>& ptr)
            requires RConvertibleTo<T*, TVal*>
            :
            Base(static_cast<TVal*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr& operator=(const MutPtr<T>& ptr)
            requires RConvertibleTo<T*, TVal*>
        {
            _ptr = static_cast<TVal*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(TVal* ptr)
            : Base(ptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(TVal* ptr)
        {
            _ptr = ptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~MutPtr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutVal() const -> TVal&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *_mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkMutVal() const -> TVal&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *_mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto operator->() const -> TVal*
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> MutPtr<T>
            requires RPure<T> and RConvertibleTo<TVal*, T>
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unsafeAs() const -> MutPtr<T>
            requires RPure<T>
        {
            return reinterpret_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto dynAs() const -> MutPtr<T>
            requires RPolymorphic<TVal> and RPure<T> and RPolymorphic<T>
        {
            return dynamic_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asConst() const -> Ptr<TVal>
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> TVal*
        {
            return _mutPtr();
        }

        using Base::isNull;

    private:
        constexpr auto _mutPtr() const -> TVal*
        {
            return const_cast<TVal*>(_ptr);
        }

    protected:
        using Base::_ptr;
    };

    template <typename T>
    MutPtr(T* ptr) -> MutPtr<T>;

    /// --------------------------------------------------------------------------------------------
    ///
    /// --------------------------------------------------------------------------------------------
    template <>
    class MutPtr<void>: public Ptr<void>
    {
        using This = MutPtr<void>;
        using Base = Ptr<void>;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr() = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(const MutPtr&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(MutPtr&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(MutPtr&&) = default;

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr(std::nullptr_t)
            : Base(nullptr)
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr MutPtr& operator=(std::nullptr_t)
        {
            _ptr = nullptr;
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr(const MutPtr<T>& ptr)
            : Base(static_cast<void*>(ptr.unwrap()))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr& operator=(const MutPtr<T>& ptr)
        {
            _ptr = static_cast<void*>(ptr.unwrap());
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr(T* ptr)
            requires RPure<T>
            : Base(static_cast<void*>(ptr))
        {}

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr MutPtr& operator=(T* ptr)
            requires RPure<T>
        {
            _ptr = static_cast<void*>(ptr);
            return *this;
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr ~MutPtr() = default;

    public:
        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto mutVal() const -> byte&
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto checkMutVal() const -> byte&
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *unwrapAsByte();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto mutValAs() const -> T&
            requires RPure<T>
        {
            Contracts::DebugExpects(not isNull(), "Null ptr access.");

            return *unwrapAs<T>();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto checkMutValAs() const -> T&
            requires RPure<T>
        {
            Contracts::Expects(not isNull(), "Null ptr access.");

            return *unwrapAs<T>();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto as() const -> MutPtr<T>
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto asConst() const -> Ptr<void>
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrap() const -> void*
        {
            return _mutPtr();
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        template <typename T>
        constexpr auto unwrapAs() const -> T*
        {
            return static_cast<T*>(_mutPtr());
        }

        /// ----------------------------------------------------------------------------------------
        ///
        /// ----------------------------------------------------------------------------------------
        constexpr auto unwrapAsByte() const -> byte*
        {
            return static_cast<byte*>(_mutPtr());
        }

        using Base::isNull;

    private:
        constexpr auto _mutPtr() const -> void*
        {
            return const_cast<void*>(_ptr);
        }

    protected:
        using Base::_ptr;
    };

    MutPtr(void*) -> MutPtr<void>;

    /// ----------------------------------------------------------------------------------------
    ///
    /// ----------------------------------------------------------------------------------------
    constexpr auto Ptr<void>::asMut() const -> MutPtr<void>
    {
        return const_cast<void*>(_ptr);
    }
}
